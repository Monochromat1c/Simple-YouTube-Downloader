This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
build.py
README.md
youtube_downloader.py
youtube_downloader.spec
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="build.py">
import os
import site
import subprocess
import sys

def find_ytdlp():
    # Get the scripts directory
    if hasattr(site, 'getsitepackages'):
        paths = site.getsitepackages()
    else:
        paths = [site.getusersitepackages()]
    
    # Add Scripts directory to paths
    scripts_dir = os.path.join(os.path.dirname(sys.executable), 'Scripts')
    paths.append(scripts_dir)
    
    # Look for yt-dlp executable
    for path in paths:
        ytdlp_path = os.path.join(path, 'yt-dlp.exe')
        if os.path.exists(ytdlp_path):
            return ytdlp_path
    
    return None

def build_exe():
    ytdlp_path = find_ytdlp()
    if not ytdlp_path:
        print("Error: Could not find yt-dlp.exe")
        return

    icon_path = os.path.join('assets', 'icon', 'icon.ico')
    
    command = [
        'pyinstaller',
        '--onefile',
        '--windowed',
        f'--icon={icon_path}',
        f'--add-binary={ytdlp_path};.',
        f'--add-data={icon_path};assets/icon',
        'youtube_downloader.py'
    ]
    
    print(f"Building with yt-dlp from: {ytdlp_path}")
    subprocess.run(command)

if __name__ == "__main__":
    build_exe()
</file>

<file path="youtube_downloader.spec">
# -*- mode: python ; coding: utf-8 -*-


a = Analysis(
    ['youtube_downloader.py'],
    pathex=[],
    binaries=[('C:\\Users\\Charles\\AppData\\Local\\Programs\\Python\\Python313\\Scripts\\yt-dlp.exe', '.')],
    datas=[('assets\\icon\\icon.ico', 'assets/icon')],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='youtube_downloader',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=['assets\\icon\\icon.ico'],
)
</file>

<file path="README.md">
# YouTube Downloader

This script allows you to download YouTube videos and audio.

## Dependencies

This project uses the following dependencies:

*   **yt-dlp:** The core library for downloading videos.
*   **ffmpeg (Optional but Recommended):** For improved audio/video quality.

## Installation

1.  **Install Python packages:**

    ```bash
    pip install yt-dlp
    ```

2.  **Install ffmpeg (Optional):**

    *   **Windows:** The recommended way is using Chocolatey:
        1.  Install Chocolatey: Open PowerShell as Administrator and run:

            ```powershell
            Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            ```
        2.  Install ffmpeg: Close and reopen PowerShell (as Administrator), then run:

            ```powershell
            choco install ffmpeg -y
            ```
    *   **macOS:** The recommended way is using Homebrew:
        1. Install Homebrew (if you don't have it):
           ```bash
           /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
           ```
        2. Install ffmpeg:
           ```bash
           brew install ffmpeg
           ```
    *   **Linux (Debian/Ubuntu):**
        ```bash
        sudo apt update
        sudo apt install ffmpeg
        ```
    *   **Linux (Fedora/CentOS/RHEL):**
        ```bash
        sudo dnf install ffmpeg
        ```

## Running the Application

### Method 1: Running from Source
```bash
python youtube_downloader.py
```

### Method 2: Using the Executable
1. Download the latest release
2. Make sure FFmpeg is installed on your system
3. Run the executable file

The application will provide a simple GUI where you can:
- Enter a YouTube URL
- Choose between video or audio download
- Click Download to start the process

## Building the Executable
To build the executable yourself:

1. Install the required packages:
   ```bash
   pip install pyinstaller yt-dlp
   ```

2. Run the build script:
   ```bash
   python build.py
   ```
</file>

<file path="youtube_downloader.py">
import requests
from bs4 import BeautifulSoup
import json
import re
import subprocess
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import time
import os

def get_downloads_folder():
    """Get the default downloads folder path"""
    return os.path.join(os.path.expanduser("~"), "Downloads")

def download_video(video_url, download_type, output_callback, download_path):
    """Downloads the video from the given URL using yt-dlp."""
    if download_type == 'v':
        format_arg = 'bv*[ext=mp4][height<=1080]+ba/b[ext=mp4]'
        format_sort_arg = '-S ext:webm:none'
    elif download_type == 'a':
        format_arg = 'ba[ext=m4a]/ba[ext=mp3]'
        format_sort_arg = '-S ares'
    else:
        output_callback("Invalid download type.\n")
        return

    # Create output template with download path
    output_template = os.path.join(download_path, "%(title)s.%(ext)s")

    command = [
        "yt-dlp",
        "-f", format_arg,
        format_sort_arg,
        "--no-playlist",
        "-o", output_template,
        video_url
    ]

    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                output_callback(output)
        _, stderr = process.communicate()
        if stderr:
            output_callback(stderr)

    except subprocess.CalledProcessError as e:
        output_callback(f"Error downloading video:\n{e.stderr}\n")

def select_directory(current_path_var):
    """Open directory selection dialog"""
    dir_path = filedialog.askdirectory(initialdir=current_path_var.get())
    if dir_path:  # If a directory was selected
        current_path_var.set(dir_path)

def download_button_clicked(root, url_entry, download_type, output_text, download_path_var):
    """Handles the download button click event."""
    video_url = url_entry.get()
    download_type_str = 'v' if download_type.get() == 1 else 'a'
    output_text.insert(tk.END, f"Downloading to: {download_path_var.get()}\n")
    output_text.insert(tk.END, f"Downloading: {video_url}\n")
    output_text.see(tk.END)
    root.update()
    
    def update_output(text):
        output_text.insert(tk.END, text)
        output_text.see(tk.END)
        root.update()

    download_video(video_url, download_type_str, update_output, download_path_var.get())
    output_text.insert(tk.END, "Download Success!\n")
    output_text.see(tk.END)
    root.update()
    root.after(2000, lambda: (output_text.delete("1.0", tk.END), url_entry.delete(0, tk.END)))

def check_ffmpeg():
    """Check if FFmpeg is available in the system PATH"""
    try:
        subprocess.run(['ffmpeg', '-version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except FileNotFoundError:
        return False

def create_gui():
    """Creates the Tkinter GUI."""
    root = tk.Tk()
    root.title("YouTube Downloader")
    
    # Set window icon using sys._MEIPASS for PyInstaller
    try:
        import sys
        if getattr(sys, 'frozen', False):
            # Running as compiled executable
            base_path = sys._MEIPASS
        else:
            # Running as script
            base_path = os.path.dirname(os.path.abspath(__file__))
        
        icon_path = os.path.join(base_path, 'assets', 'icon', 'icon.ico')
        root.iconbitmap(icon_path)
    except:
        # If icon loading fails, continue without icon
        pass
    
    # Make window stay on top and prevent resizing
    root.attributes('-topmost', True)
    root.resizable(False, False)

    # Change title bar color (Windows 11 only)
    try:
        from ctypes import windll, c_int, byref, sizeof
        HWND = windll.user32.GetParent(root.winfo_id())
        windll.dwmapi.DwmSetWindowAttribute(
            HWND,
            35,  # DWMWA_CAPTION_COLOR
            byref(c_int(0x00382515)),  # RGB(21, 37, 56) -> BGR format
            sizeof(c_int)
        )
    except:
        pass  # Fail silently if not on Windows 11 or if it doesn't work

    # Check FFmpeg availability
    if not check_ffmpeg():
        tk.messagebox.showerror(
            "FFmpeg Not Found", 
            "FFmpeg is required but not found in system PATH.\n"
            "Please install FFmpeg from https://ffmpeg.org/download.html"
        )

    # Download Path
    download_path_var = tk.StringVar(value=get_downloads_folder())
    path_frame = ttk.Frame(root)
    path_frame.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
    
    path_label = ttk.Label(path_frame, text="Download Location:")
    path_label.pack(side=tk.LEFT, padx=(0, 5))
    
    path_entry = ttk.Entry(path_frame, textvariable=download_path_var, width=40)
    path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    browse_button = ttk.Button(path_frame, text="Browse", 
                             command=lambda: select_directory(download_path_var))
    browse_button.pack(side=tk.RIGHT, padx=(5, 0))

    # URL Entry and Download Button Frame
    url_button_frame = ttk.Frame(root)
    url_button_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

    # URL Entry
    url_label = ttk.Label(url_button_frame, text="YouTube URL:")
    url_label.pack(side=tk.LEFT, padx=(0, 5))
    url_entry = ttk.Entry(url_button_frame, width=50)
    url_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
    
    # Download Button
    download_button = ttk.Button(
        url_button_frame,
        text="Download",
        command=lambda: download_button_clicked(
            root, url_entry, download_type, output_text, download_path_var
        )
    )
    download_button.pack(side=tk.LEFT, padx=(5,0))

    # Download Type (Radio Buttons)
    radio_frame = ttk.Frame(root)
    radio_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="w")
    
    download_type = tk.IntVar(value=1)  # 1 for video, 2 for audio
    video_radio = ttk.Radiobutton(radio_frame, text="Video", variable=download_type, value=1)
    video_radio.pack(side=tk.LEFT)
    audio_radio = ttk.Radiobutton(radio_frame, text="Audio", variable=download_type, value=2)
    audio_radio.pack(side=tk.LEFT, padx=(10, 0))  # 10 pixels space between radio buttons

    # Output Text Area
    output_text = scrolledtext.ScrolledText(root, width=60, height=10)
    output_text.grid(row=4, column=0, columnspan=2, padx=5, pady=5)

    root.mainloop()

if __name__ == "__main__":
    create_gui()
</file>

</files>
